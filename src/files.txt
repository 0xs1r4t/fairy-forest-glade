. Directory Structure and File Contents:

<.-Directory-Structure>

src/
├── headers/
│   ├── app.h
│   ├── camera.h
│   ├── mesh.h
│   ├── model.h
│   ├── renderer.h
│   └── shader.h
├── shaders/
│   ├── model.frag
│   ├── model.vert
│   ├── shader.frag
│   └── shader.vert
├── utils/
│   ├── app.cpp
│   ├── camera.cpp
│   ├── renderer.cpp
│   └── shader.cpp
├── files.txt
├── main.cpp
└── main.exe

<.-Directory-Structure>

<.-File-Contents>

headers\app.h:
```
#pragma once

/* forward-declare GLFWwindow to avoid pulling in glfw3.h into the header.
   Include <GLFW/glfw3.h> in the .cpp files where needed (so you can control
   that <GL/glew.h> is included before GLFW). */
struct GLFWwindow;
#include <string>
#include "shader.h"
#include "renderer.h"
#include "model.h"

class App
{
public:
    App(int width, int height, const char *title);
    ~App();
    int run();

private:
    bool initGL();
    GLFWwindow *window_;
    int width_, height_;
    std::string title_;
    Shader shader_;
    Renderer renderer_;
    Camera camera_;
    Model *model_; // <--- load model at init time (pointer so we can construct after resolving paths)
};
```

headers\camera.h:
```
#pragma once

#include <GL/glew.h>
#include <GLFW/glfw3.h>
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/type_ptr.hpp>
#include <glm/gtx/rotate_vector.hpp>
#include <glm/gtx/vector_angle.hpp>

#include "shader.h"

class Camera
{
public:
    glm::vec3 Position;
    glm::vec3 Orientation = glm::vec3(0.0f, 0.0f, -1.0f);
    glm::vec3 Up = glm::vec3(0.0f, 1.0f, 0.0f);

    int width;
    int height;

    // Modify these values for better control
    float speed = 0.1f;
    float sensitivity = 0.1f;

    // Add middle mouse pan support
    bool isPanning = false;
    bool isOrbiting = false;
    glm::vec3 target = glm::vec3(0.0f, 0.0f, 0.0f);
    float orbitDistance = 5.0f;

    // Add these new members
    bool firstClick = true;
    bool cursorCaptured = false;
    float yaw = -90.0f;
    float pitch = 0.0f;
    double lastX = 0.0f;
    double lastY = 0.0f;

    Camera(int width, int height, glm::vec3 position);

    void Matrix(float FOVdeg, float nearPlane, float farPlane, Shader &shader, const char *uniform);
    void Inputs(GLFWwindow *window);
};
```

headers\mesh.h:
```
#pragma once

#include <vector>
#include <GL/glew.h>
#include <glm/glm.hpp>

struct Vertex
{
    glm::vec3 Position;
    glm::vec3 Normal;
    glm::vec2 TexCoords;
};

class Mesh
{
public:
    std::vector<Vertex> vertices;
    std::vector<unsigned int> indices;
    GLuint VAO;

    Mesh(const std::vector<Vertex> &vertices, const std::vector<unsigned int> &indices)
    {
        this->vertices = vertices;
        this->indices = indices;
        setupMesh();
    }

private:
    GLuint VBO, EBO;

    void setupMesh()
    {
        glGenVertexArrays(1, &VAO);
        glGenBuffers(1, &VBO);
        glGenBuffers(1, &EBO);

        glBindVertexArray(VAO);
        glBindBuffer(GL_ARRAY_BUFFER, VBO);
        glBufferData(GL_ARRAY_BUFFER, vertices.size() * sizeof(Vertex), &vertices[0], GL_STATIC_DRAW);

        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);
        glBufferData(GL_ELEMENT_ARRAY_BUFFER, indices.size() * sizeof(unsigned int), &indices[0], GL_STATIC_DRAW);

        // vertex positions
        glEnableVertexAttribArray(0);
        glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void *)0);
        // vertex normals
        glEnableVertexAttribArray(1);
        glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void *)offsetof(Vertex, Normal));
        // vertex texture coords
        glEnableVertexAttribArray(2);
        glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void *)offsetof(Vertex, TexCoords));

        glBindVertexArray(0);
    }
};

```

headers\model.h:
```
#pragma once

#include <assimp/Importer.hpp>
#include <assimp/scene.h>
#include <assimp/postprocess.h>
#include "mesh.h"
#include <string>
#include <vector>
#include <iostream> // <-- added so std::cout / std::endl are available

class Model
{
public:
    std::vector<Mesh> meshes;

    Model(const char *path)
    {
        loadModel(path);
    }

private:
    void loadModel(std::string path)
    {
        Assimp::Importer importer;
        const aiScene *scene = importer.ReadFile(path, aiProcess_Triangulate | aiProcess_GenNormals);

        if (!scene || scene->mFlags & AI_SCENE_FLAGS_INCOMPLETE || !scene->mRootNode)
        {
            std::cout << "Assimp error: " << importer.GetErrorString() << std::endl;
            return;
        }

        processNode(scene->mRootNode, scene);
    }

    void processNode(aiNode *node, const aiScene *scene)
    {
        // process all meshes in current node
        for (unsigned int i = 0; i < node->mNumMeshes; i++)
        {
            aiMesh *mesh = scene->mMeshes[node->mMeshes[i]];
            meshes.push_back(processMesh(mesh, scene));
        }
        // process children nodes
        for (unsigned int i = 0; i < node->mNumChildren; i++)
        {
            processNode(node->mChildren[i], scene);
        }
    }

    Mesh processMesh(aiMesh *mesh, const aiScene *scene)
    {
        std::vector<Vertex> vertices;
        std::vector<unsigned int> indices;

        // process vertices
        for (unsigned int i = 0; i < mesh->mNumVertices; i++)
        {
            Vertex vertex;
            vertex.Position = glm::vec3(
                mesh->mVertices[i].x,
                mesh->mVertices[i].y,
                mesh->mVertices[i].z);
            vertex.Normal = glm::vec3(
                mesh->mNormals[i].x,
                mesh->mNormals[i].y,
                mesh->mNormals[i].z);
            if (mesh->mTextureCoords[0])
            {
                vertex.TexCoords = glm::vec2(
                    mesh->mTextureCoords[0][i].x,
                    mesh->mTextureCoords[0][i].y);
            }
            else
            {
                vertex.TexCoords = glm::vec2(0.0f, 0.0f);
            }
            vertices.push_back(vertex);
        }

        // process indices
        for (unsigned int i = 0; i < mesh->mNumFaces; i++)
        {
            aiFace face = mesh->mFaces[i];
            for (unsigned int j = 0; j < face.mNumIndices; j++)
                indices.push_back(face.mIndices[j]);
        }

        return Mesh(vertices, indices);
    }
};

```

headers\renderer.h:
```
#pragma once

#include <GL/glew.h>
#include "model.h"
#include "shader.h"

class Renderer
{
public:
    Renderer();
    ~Renderer();

    void init();
    void drawTriangle(const Shader &shader) const;
    void drawModel(const Model &model) const;

private:
    GLuint vao_, vbo_;
    bool initialized_;
};

```

headers\shader.h:
```
#pragma once

#include <GL/glew.h>
#include <glm/glm.hpp>
#include <string>

class Shader
{
public:
    explicit Shader(const char *vertPath = nullptr, const char *fragPath = nullptr);
    ~Shader();

    bool valid() const;
    void use() const;
    GLuint id() const;

    void setMat4(const std::string &name, const glm::mat4 &mat) const;

private:
    GLuint program_;
    // helper
    static std::string readFile(const char *path);
    static GLuint compileShader(GLenum type, const char *source);
    static GLuint createProgramFromFiles(const char *vertPath, const char *fragPath);
};

```

shaders\model.frag:
```
#version 330 core
out vec4 FragColor;

in vec3 Normal;
in vec3 FragPos;

uniform vec3 lightPos;
uniform vec3 viewPos;
uniform vec3 lightColor;
uniform vec3 objectColor;

uniform mat4 cameraMatrix;

void main() {
    // ambient
    float ambientStrength = 0.1;
    vec3 ambient = ambientStrength * lightColor;

    // diffuse
    vec3 norm = normalize(Normal);
    vec3 lightDir = normalize(lightPos - FragPos);
    float diff = max(dot(norm, lightDir), 0.0);
    vec3 diffuse = diff * lightColor;

    vec3 result = (ambient + diffuse) * objectColor;
    FragColor = vec4(result, 1.0);
}
```

shaders\model.vert:
```
#version 330 core
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec3 aNormal;
layout (location = 2) in vec2 aTexCoords;

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;

out vec3 Normal;
out vec3 FragPos;

void main() {
    FragPos = vec3(model * vec4(aPos, 1.0));
    Normal = mat3(transpose(inverse(model))) * aNormal;
    gl_Position = projection * view * vec4(FragPos, 1.0);
}
```

shaders\shader.frag:
```
#version 330 core
out vec4 FragColor;
void main() {
    FragColor = vec4(1.0, 0.5, 0.2, 1.0);
}
```

shaders\shader.vert:
```
#version 330 core
layout(location = 0) in vec3 position;
void main() {
    gl_Position = vec4(position, 1.0);
}
```

utils\app.cpp:
```cpp
#define GLM_ENABLE_EXPERIMENTAL
#include <GL/glew.h>
#include <GLFW/glfw3.h>
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/type_ptr.hpp>
#include <iostream>
#include <filesystem>

#include "camera.h"
#include "app.h"

App::App(int width, int height, const char *title)
    : window_(nullptr),
      width_(width),
      height_(height),
      title_(title),
      shader_(nullptr, nullptr),
      renderer_(),
      model_(nullptr),
      camera_(width, height, glm::vec3(0.0f, 0.0f, 3.0f)) // Initialize camera with starting position
{
}

App::~App()
{
    if (model_)
        delete model_;
    if (shader_.valid())
        ; // shader destructor cleans up
    if (window_)
    {
        glfwDestroyWindow(window_);
        glfwTerminate();
    }
}

bool App::initGL()
{
    if (!glfwInit())
    {
        std::cerr << "Failed to initialize GLFW\n";
        return false;
    }

    window_ = glfwCreateWindow(width_, height_, title_.c_str(), nullptr, nullptr);
    if (!window_)
    {
        std::cerr << "Failed to create GLFW window\n";
        glfwTerminate();
        return false;
    }

    glfwMakeContextCurrent(window_);

    if (glewInit() != GLEW_OK)
    {
        std::cerr << "Failed to initialize GLEW\n";
        return false;
    }

    // resolve resource paths relative to current working directory and verify
    namespace fs = std::filesystem;
    fs::path base = fs::current_path(); // prints helpful info if needed
    fs::path vertPath = base / "src" / "shaders" / "model.vert";
    fs::path fragPath = base / "src" / "shaders" / "model.frag";
    fs::path modelPath = base / "src" / "models" / "monkey.obj";

    std::cout << "Using shader: " << vertPath << " and " << fragPath << std::endl;
    std::cout << "Using model: " << modelPath << std::endl;

    if (!fs::exists(vertPath) || !fs::exists(fragPath))
    {
        std::cerr << "Shader files not found. Make sure paths are correct relative to working dir: " << base << std::endl;
        return false;
    }

    if (!fs::exists(modelPath))
    {
        std::cerr << "Model file not found. Make sure paths are correct relative to working dir: " << base << std::endl;
        return false;
    }

    // create shader program
    shader_ = Shader(vertPath.string().c_str(), fragPath.string().c_str());
    if (!shader_.valid())
    {
        std::cerr << "Failed to create shader program\n";
        return false;
    }

    // load model after verifying path
    model_ = new Model(modelPath.string().c_str());

    renderer_.init();

    return true;
}

int App::run()
{
    if (!initGL())
        return -1;

    // Enable depth testing
    glEnable(GL_DEPTH_TEST);

    // Set initial cursor mode to disabled for camera control
    glfwSetInputMode(window_, GLFW_CURSOR, GLFW_CURSOR_DISABLED);
    camera_.cursorCaptured = true;

    // Set a reasonable starting position and speed
    camera_.Position = glm::vec3(0.0f, 2.0f, 5.0f);
    camera_.speed = 0.1f;       // Increase speed for better control
    camera_.sensitivity = 0.1f; // Reduce sensitivity for smoother camera

    while (!glfwWindowShouldClose(window_))
    {
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

        shader_.use();

        // Handle camera movement
        camera_.Inputs(window_);

        // Update camera matrices
        camera_.Matrix(45.0f, 0.1f, 100.0f, shader_, "projection");

        glm::mat4 view = glm::lookAt(
            camera_.Position,
            camera_.Position + camera_.Orientation,
            camera_.Up);
        shader_.setMat4("view", view);

        // simple model/view/proj
        // glm::mat4 model = glm::mat4(1.0f);
        // glm::mat4 view = glm::lookAt(glm::vec3(0.0f, 0.0f, 3.0f),
        //                              glm::vec3(0.0f, 0.0f, 0.0f),
        //                              glm::vec3(0.0f, 1.0f, 0.0f));
        // glm::mat4 projection = glm::perspective(glm::radians(45.0f),
        //                                         (float)width_ / (float)height_, 0.1f, 100.0f);

        // shader_.setMat4("model", model);
        // shader_.setMat4("view", view);
        // shader_.setMat4("projection", projection);

        // draw simple triangle
        renderer_.drawTriangle(shader_);

        // draw loaded model (check pointer)
        if (model_)
            renderer_.drawModel(*model_);

        glfwSwapBuffers(window_);
        glfwPollEvents();
    }

    return 0;
}
```

utils\camera.cpp:
```cpp
#define GLM_ENABLE_EXPERIMENTAL
#include "camera.h"

#include <iostream>

/**
 * @brief Construct a new Camera:: Camera object
 *
 * @param width
 * @param height
 * @param position
 *
 * Additional Notes:
 * First Person POV, Perspective View
 * - Camera moves with the player
 * - As if the player is seeing through the camera
 *
 * Third Person POV, Orthographic View
 * - Camera follows the player from a set distance (fixed offset)
 * - Player is always visible on screen
 */

Camera::Camera(int width, int height, glm::vec3 position)
{
    this->width = width;
    this->height = height;
    this->Position = position;

    // Initialize camera values
    this->speed = 0.1f;
    this->sensitivity = 0.1f;
    this->yaw = -90.0f;
    this->pitch = 0.0f;
    this->firstClick = true;
    this->cursorCaptured = false;

    // Calculate initial orientation
    glm::vec3 direction;
    direction.x = cos(glm::radians(yaw)) * cos(glm::radians(pitch));
    direction.y = sin(glm::radians(pitch));
    direction.z = sin(glm::radians(yaw)) * cos(glm::radians(pitch));
    this->Orientation = glm::normalize(direction);

    std::cout << "Camera initialized at position: "
              << position.x << ", " << position.y << ", " << position.z << std::endl;
}

void Camera::Matrix(float FOVdeg, float nearPlane, float farPlane, Shader &shader, const char *uniform)
{
    // perspective projection matrix
    glm::mat4 projection = glm::perspective(glm::radians(FOVdeg), (float)width / (float)height, nearPlane, farPlane);
    shader.setMat4(uniform, projection);
}

// can add orthographic projection later

void Camera::Inputs(GLFWwindow *window)
{
    // Debug output for key states
    if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS)
    {
        std::cout << "W pressed - Position before: " << Position.x << ", " << Position.y << ", " << Position.z << std::endl;
        Position += speed * Orientation;
        std::cout << "Position after: " << Position.x << ", " << Position.y << ", " << Position.z << std::endl;
    }

    // Check cursor state
    if (glfwGetKey(window, GLFW_KEY_TAB) == GLFW_PRESS)
    {
        cursorCaptured = !cursorCaptured;
        std::cout << "Cursor captured: " << (cursorCaptured ? "true" : "false") << std::endl;
        glfwSetInputMode(window, GLFW_CURSOR,
                         cursorCaptured ? GLFW_CURSOR_DISABLED : GLFW_CURSOR_NORMAL);
        firstClick = true;
    }

    if (cursorCaptured)
    {
        // Get mouse position
        double mouseX, mouseY;
        glfwGetCursorPos(window, &mouseX, &mouseY);

        if (firstClick)
        {
            lastX = mouseX;
            lastY = mouseY;
            firstClick = false;
        }

        float xOffset = mouseX - lastX;
        float yOffset = lastY - mouseY;
        lastX = mouseX;
        lastY = mouseY;

        // Adjust sensitivity
        xOffset *= sensitivity;
        yOffset *= sensitivity;

        // Middle mouse button for orbit
        if (glfwGetMouseButton(window, GLFW_MOUSE_BUTTON_MIDDLE) == GLFW_PRESS)
        {
            // Orbit around target point
            yaw += xOffset;
            pitch += yOffset;

            // Clamp pitch
            pitch = glm::clamp(pitch, -89.0f, 89.0f);

            // Calculate new position
            float x = cos(glm::radians(yaw)) * cos(glm::radians(pitch));
            float y = sin(glm::radians(pitch));
            float z = sin(glm::radians(yaw)) * cos(glm::radians(pitch));

            Position = target + orbitDistance * glm::normalize(glm::vec3(x, y, z));
            Orientation = glm::normalize(target - Position);
        }
        else
        {
            // Regular first-person camera rotation
            yaw += xOffset;
            pitch += yOffset;
            pitch = glm::clamp(pitch, -89.0f, 89.0f);

            glm::vec3 direction;
            direction.x = cos(glm::radians(yaw)) * cos(glm::radians(pitch));
            direction.y = sin(glm::radians(pitch));
            direction.z = sin(glm::radians(yaw)) * cos(glm::radians(pitch));
            Orientation = glm::normalize(direction);
        }

        // Handle keyboard input
        if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS)
            Position += speed * Orientation;
        if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS)
            Position -= speed * Orientation;
        if (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS)
            Position -= glm::normalize(glm::cross(Orientation, Up)) * speed;
        if (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS)
            Position += glm::normalize(glm::cross(Orientation, Up)) * speed;
        if (glfwGetKey(window, GLFW_KEY_SPACE) == GLFW_PRESS)
            Position += Up * speed;
        if (glfwGetKey(window, GLFW_KEY_LEFT_CONTROL) == GLFW_PRESS)
            Position -= Up * speed;
    }
}

```

utils\renderer.cpp:
```cpp
#include "renderer.h"
#include <array>

Renderer::Renderer() : vao_(0), vbo_(0), initialized_(false) {}

Renderer::~Renderer()
{
    if (vbo_)
        glDeleteBuffers(1, &vbo_);
    if (vao_)
        glDeleteVertexArrays(1, &vao_);
}

void Renderer::init()
{
    if (initialized_)
        return;

    std::array<float, 9> vertices = {
        0.0f, 0.5f, 0.0f,
        -0.5f, -0.5f, 0.0f,
        0.5f, -0.5f, 0.0f};

    glGenVertexArrays(1, &vao_);
    glGenBuffers(1, &vbo_);
    glBindVertexArray(vao_);
    glBindBuffer(GL_ARRAY_BUFFER, vbo_);
    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices.data(), GL_STATIC_DRAW);

    glEnableVertexAttribArray(0);
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void *)0);

    glBindBuffer(GL_ARRAY_BUFFER, 0);
    glBindVertexArray(0);

    initialized_ = true;
}

void Renderer::drawTriangle(const Shader & /*shader*/) const
{
    if (!initialized_)
        return;
    glBindVertexArray(vao_);
    glDrawArrays(GL_TRIANGLES, 0, 3);
    glBindVertexArray(0);
}

void Renderer::drawModel(const Model &model) const
{
    for (const auto &mesh : model.meshes)
    {
        glBindVertexArray(mesh.VAO);
        glDrawElements(GL_TRIANGLES, static_cast<GLsizei>(mesh.indices.size()), GL_UNSIGNED_INT, 0);
        glBindVertexArray(0);
    }
}
```

utils\shader.cpp:
```cpp
#include "shader.h"
#include <fstream>
#include <sstream>
#include <iostream>

std::string Shader::readFile(const char *path)
{
    std::ifstream in(path, std::ios::in | std::ios::binary);
    if (!in)
    {
        std::cerr << "Failed to open file: " << path << "\n";
        return "";
    }
    std::ostringstream contents;
    contents << in.rdbuf();
    return contents.str();
}

GLuint Shader::compileShader(GLenum type, const char *source)
{
    GLuint shader = glCreateShader(type);
    glShaderSource(shader, 1, &source, nullptr);
    glCompileShader(shader);

    GLint compiled = 0;
    glGetShaderiv(shader, GL_COMPILE_STATUS, &compiled);
    if (!compiled)
    {
        GLint len = 0;
        glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &len);
        std::string log(len, ' ');
        glGetShaderInfoLog(shader, len, &len, &log[0]);
        std::cerr << "Shader compile error: " << log << "\n";
        glDeleteShader(shader);
        return 0;
    }
    return shader;
}

GLuint Shader::createProgramFromFiles(const char *vertPath, const char *fragPath)
{
    std::string vertSrc = readFile(vertPath);
    std::string fragSrc = readFile(fragPath);
    if (vertSrc.empty() || fragSrc.empty())
    {
        std::cerr << "One or both shader sources are empty\n";
        return 0;
    }

    GLuint vert = compileShader(GL_VERTEX_SHADER, vertSrc.c_str());
    if (!vert)
        return 0;
    GLuint frag = compileShader(GL_FRAGMENT_SHADER, fragSrc.c_str());
    if (!frag)
    {
        glDeleteShader(vert);
        return 0;
    }

    GLuint program = glCreateProgram();
    glAttachShader(program, vert);
    glAttachShader(program, frag);
    glLinkProgram(program);

    GLint linked = 0;
    glGetProgramiv(program, GL_LINK_STATUS, &linked);
    if (!linked)
    {
        GLint len = 0;
        glGetProgramiv(program, GL_INFO_LOG_LENGTH, &len);
        std::string log(len, ' ');
        glGetProgramInfoLog(program, len, &len, &log[0]);
        std::cerr << "Program link error: " << log << "\n";
        glDeleteProgram(program);
        program = 0;
    }

    glDetachShader(program, vert);
    glDetachShader(program, frag);
    glDeleteShader(vert);
    glDeleteShader(frag);

    return program;
}

Shader::Shader(const char *vertPath, const char *fragPath)
    : program_(0)
{
    if (vertPath && fragPath)
        program_ = createProgramFromFiles(vertPath, fragPath);
}

Shader::~Shader()
{
    if (program_)
        glDeleteProgram(program_);
}

bool Shader::valid() const { return program_ != 0; }
void Shader::use() const
{
    if (program_)
        glUseProgram(program_);
}
GLuint Shader::id() const { return program_; }

void Shader::setMat4(const std::string &name, const glm::mat4 &mat) const
{
    if (!program_)
        return;
    GLint loc = glGetUniformLocation(program_, name.c_str());
    if (loc >= 0)
        glUniformMatrix4fv(loc, 1, GL_FALSE, &mat[0][0]);
}
```

files.txt:
```
. Directory Structure and File Contents:

<.-Directory-Structure>

src/
├── headers/
│   ├── app.h
│   ├── camera.h
│   ├── mesh.h
│   ├── model.h
│   ├── renderer.h
│   └── shader.h
├── shaders/
│   ├── model.frag
│   ├── model.vert
│   ├── shader.frag
│   └── shader.vert
├── utils/
│   ├── app.cpp
│   ├── camera.cpp
│   ├── renderer.cpp
│   └── shader.cpp
├── files.txt
├── main.cpp
└── main.exe

<.-Directory-Structure>

<.-File-Contents>

headers\app.h:
```
#pragma once

/* forward-declare GLFWwindow to avoid pulling in glfw3.h into the header.
   Include <GLFW/glfw3.h> in the .cpp files where needed (so you can control
   that <GL/glew.h> is included before GLFW). */
struct GLFWwindow;
#include <string>
#include "shader.h"
#include "renderer.h"
#include "model.h"

class App
{
public:
    App(int width, int height, const char *title);
    ~App();
    int run();

private:
    bool initGL();
    GLFWwindow *window_;
    int width_, height_;
    std::string title_;
    Shader shader_;
    Renderer renderer_;
    Camera camera_;
    Model *model_; // <--- load model at init time (pointer so we can construct after resolving paths)
};
```

headers\camera.h:
```
#pragma once

#include <GL/glew.h>
#include <GLFW/glfw3.h>
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/type_ptr.hpp>
#include <glm/gtx/rotate_vector.hpp>
#include <glm/gtx/vector_angle.hpp>

#include "shader.h"

class Camera
{
public:
    glm::vec3 Position;
    glm::vec3 Orientation = glm::vec3(0.0f, 0.0f, -1.0f);
    glm::vec3 Up = glm::vec3(0.0f, 1.0f, 0.0f);

    int width;
    int height;

    // Modify these values for better control
    float speed = 0.1f;
    float sensitivity = 0.1f;

    // Add middle mouse pan support
    bool isPanning = false;
    bool isOrbiting = false;
    glm::vec3 target = glm::vec3(0.0f, 0.0f, 0.0f);
    float orbitDistance = 5.0f;

    // Add these new members
    bool firstClick = true;
    bool cursorCaptured = false;
    float yaw = -90.0f;
    float pitch = 0.0f;
    double lastX = 0.0f;
    double lastY = 0.0f;

    Camera(int width, int height, glm::vec3 position);

    void Matrix(float FOVdeg, float nearPlane, float farPlane, Shader &shader, const char *uniform);
    void Inputs(GLFWwindow *window);
};
```

headers\mesh.h:
```
#pragma once

#include <vector>
#include <GL/glew.h>
#include <glm/glm.hpp>

struct Vertex
{
    glm::vec3 Position;
    glm::vec3 Normal;
    glm::vec2 TexCoords;
};

class Mesh
{
public:
    std::vector<Vertex> vertices;
    std::vector<unsigned int> indices;
    GLuint VAO;

    Mesh(const std::vector<Vertex> &vertices, const std::vector<unsigned int> &indices)
    {
        this->vertices = vertices;
        this->indices = indices;
        setupMesh();
    }

private:
    GLuint VBO, EBO;

    void setupMesh()
    {
        glGenVertexArrays(1, &VAO);
        glGenBuffers(1, &VBO);
        glGenBuffers(1, &EBO);

        glBindVertexArray(VAO);
        glBindBuffer(GL_ARRAY_BUFFER, VBO);
        glBufferData(GL_ARRAY_BUFFER, vertices.size() * sizeof(Vertex), &vertices[0], GL_STATIC_DRAW);

        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);
        glBufferData(GL_ELEMENT_ARRAY_BUFFER, indices.size() * sizeof(unsigned int), &indices[0], GL_STATIC_DRAW);

        // vertex positions
        glEnableVertexAttribArray(0);
        glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void *)0);
        // vertex normals
        glEnableVertexAttribArray(1);
        glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void *)offsetof(Vertex, Normal));
        // vertex texture coords
        glEnableVertexAttribArray(2);
        glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void *)offsetof(Vertex, TexCoords));

        glBindVertexArray(0);
    }
};

```

headers\model.h:
```
#pragma once

#include <assimp/Importer.hpp>
#include <assimp/scene.h>
#include <assimp/postprocess.h>
#include "mesh.h"
#include <string>
#include <vector>
#include <iostream> // <-- added so std::cout / std::endl are available

class Model
{
public:
    std::vector<Mesh> meshes;

    Model(const char *path)
    {
        loadModel(path);
    }

private:
    void loadModel(std::string path)
    {
        Assimp::Importer importer;
        const aiScene *scene = importer.ReadFile(path, aiProcess_Triangulate | aiProcess_GenNormals);

        if (!scene || scene->mFlags & AI_SCENE_FLAGS_INCOMPLETE || !scene->mRootNode)
        {
            std::cout << "Assimp error: " << importer.GetErrorString() << std::endl;
            return;
        }

        processNode(scene->mRootNode, scene);
    }

    void processNode(aiNode *node, const aiScene *scene)
    {
        // process all meshes in current node
        for (unsigned int i = 0; i < node->mNumMeshes; i++)
        {
            aiMesh *mesh = scene->mMeshes[node->mMeshes[i]];
            meshes.push_back(processMesh(mesh, scene));
        }
        // process children nodes
        for (unsigned int i = 0; i < node->mNumChildren; i++)
        {
            processNode(node->mChildren[i], scene);
        }
    }

    Mesh processMesh(aiMesh *mesh, const aiScene *scene)
    {
        std::vector<Vertex> vertices;
        std::vector<unsigned int> indices;

        // process vertices
        for (unsigned int i = 0; i < mesh->mNumVertices; i++)
        {
            Vertex vertex;
            vertex.Position = glm::vec3(
                mesh->mVertices[i].x,
                mesh->mVertices[i].y,
                mesh->mVertices[i].z);
            vertex.Normal = glm::vec3(
                mesh->mNormals[i].x,
                mesh->mNormals[i].y,
                mesh->mNormals[i].z);
            if (mesh->mTextureCoords[0])
            {
                vertex.TexCoords = glm::vec2(
                    mesh->mTextureCoords[0][i].x,
                    mesh->mTextureCoords[0][i].y);
            }
            else
            {
                vertex.TexCoords = glm::vec2(0.0f, 0.0f);
            }
            vertices.push_back(vertex);
        }

        // process indices
        for (unsigned int i = 0; i < mesh->mNumFaces; i++)
        {
            aiFace face = mesh->mFaces[i];
            for (unsigned int j = 0; j < face.mNumIndices; j++)
                indices.push_back(face.mIndices[j]);
        }

        return Mesh(vertices, indices);
    }
};

```

headers\renderer.h:
```
#pragma once

#include <GL/glew.h>
#include "model.h"
#include "shader.h"

class Renderer
{
public:
    Renderer();
    ~Renderer();

    void init();
    void drawTriangle(const Shader &shader) const;
    void drawModel(const Model &model) const;

private:
    GLuint vao_, vbo_;
    bool initialized_;
};

```

headers\shader.h:
```
#pragma once

#include <GL/glew.h>
#include <glm/glm.hpp>
#include <string>

class Shader
{
public:
    explicit Shader(const char *vertPath = nullptr, const char *fragPath = nullptr);
    ~Shader();

    bool valid() const;
    void use() const;
    GLuint id() const;

    void setMat4(const std::string &name, const glm::mat4 &mat) const;

private:
    GLuint program_;
    // helper
    static std::string readFile(const char *path);
    static GLuint compileShader(GLenum type, const char *source);
    static GLuint createProgramFromFiles(const char *vertPath, const char *fragPath);
};

```

shaders\model.frag:
```
#version 330 core
out vec4 FragColor;

in vec3 Normal;
in vec3 FragPos;

uniform vec3 lightPos;
uniform vec3 viewPos;
uniform vec3 lightColor;
uniform vec3 objectColor;

uniform mat4 cameraMatrix;

void main() {
    // ambient
    float ambientStrength = 0.1;
    vec3 ambient = ambientStrength * lightColor;

    // diffuse
    vec3 norm = normalize(Normal);
    vec3 lightDir = normalize(lightPos - FragPos);
    float diff = max(dot(norm, lightDir), 0.0);
    vec3 diffuse = diff * lightColor;

    vec3 result = (ambient + diffuse) * objectColor;
    FragColor = vec4(result, 1.0);
}
```

shaders\model.vert:
```
#version 330 core
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec3 aNormal;
layout (location = 2) in vec2 aTexCoords;

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;

out vec3 Normal;
out vec3 FragPos;

void main() {
    FragPos = vec3(model * vec4(aPos, 1.0));
    Normal = mat3(transpose(inverse(model))) * aNormal;
    gl_Position = projection * view * vec4(FragPos, 1.0);
}
```

shaders\shader.frag:
```
#version 330 core
out vec4 FragColor;
void main() {
    FragColor = vec4(1.0, 0.5, 0.2, 1.0);
}
```

shaders\shader.vert:
```
#version 330 core
layout(location = 0) in vec3 position;
void main() {
    gl_Position = vec4(position, 1.0);
}
```

utils\app.cpp:
```cpp
#define GLM_ENABLE_EXPERIMENTAL
#include <GL/glew.h>
#include <GLFW/glfw3.h>
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/type_ptr.hpp>
#include <iostream>
#include <filesystem>

#include "camera.h"
#include "app.h"

App::App(int width, int height, const char *title)
    : window_(nullptr),
      width_(width),
      height_(height),
      title_(title),
      shader_(nullptr, nullptr),
      renderer_(),
      model_(nullptr),
      camera_(width, height, glm::vec3(0.0f, 0.0f, 3.0f)) // Initialize camera with starting position
{
}

App::~App()
{
    if (model_)
        delete model_;
    if (shader_.valid())
        ; // shader destructor cleans up
    if (window_)
    {
        glfwDestroyWindow(window_);
        glfwTerminate();
    }
}

bool App::initGL()
{
    if (!glfwInit())
    {
        std::cerr << "Failed to initialize GLFW\n";
        return false;
    }

    window_ = glfwCreateWindow(width_, height_, title_.c_str(), nullptr, nullptr);
    if (!window_)
    {
        std::cerr << "Failed to create GLFW window\n";
        glfwTerminate();
        return false;
    }

    glfwMakeContextCurrent(window_);

    if (glewInit() != GLEW_OK)
    {
        std::cerr << "Failed to initialize GLEW\n";
        return false;
    }

    // resolve resource paths relative to current working directory and verify
    namespace fs = std::filesystem;
    fs::path base = fs::current_path(); // prints helpful info if needed
    fs::path vertPath = base / "src" / "shaders" / "model.vert";
    fs::path fragPath = base / "src" / "shaders" / "model.frag";
    fs::path modelPath = base / "src" / "models" / "monkey.obj";

    std::cout << "Using shader: " << vertPath << " and " << fragPath << std::endl;
    std::cout << "Using model: " << modelPath << std::endl;

    if (!fs::exists(vertPath) || !fs::exists(fragPath))
    {
        std::cerr << "Shader files not found. Make sure paths are correct relative to working dir: " << base << std::endl;
        return false;
    }

    if (!fs::exists(modelPath))
    {
        std::cerr << "Model file not found. Make sure paths are correct relative to working dir: " << base << std::endl;
        return false;
    }

    // create shader program
    shader_ = Shader(vertPath.string().c_str(), fragPath.string().c_str());
    if (!shader_.valid())
    {
        std::cerr << "Failed to create shader program\n";
        return false;
    }

    // load model after verifying path
    model_ = new Model(modelPath.string().c_str());

    renderer_.init();

    return true;
}

int App::run()
{
    if (!initGL())
        return -1;

    // Enable depth testing
    glEnable(GL_DEPTH_TEST);

    // Set initial cursor mode to disabled for camera control
    glfwSetInputMode(window_, GLFW_CURSOR, GLFW_CURSOR_DISABLED);
    camera_.cursorCaptured = true;

    // Set a reasonable starting position and speed
    camera_.Position = glm::vec3(0.0f, 2.0f, 5.0f);
    camera_.speed = 0.1f;       // Increase speed for better control
    camera_.sensitivity = 0.1f; // Reduce sensitivity for smoother camera

    while (!glfwWindowShouldClose(window_))
    {
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

        shader_.use();

        // Handle camera movement
        camera_.Inputs(window_);

        // Update camera matrices
        camera_.Matrix(45.0f, 0.1f, 100.0f, shader_, "projection");

        glm::mat4 view = glm::lookAt(
            camera_.Position,
            camera_.Position + camera_.Orientation,
            camera_.Up);
        shader_.setMat4("view", view);

        // simple model/view/proj
        // glm::mat4 model = glm::mat4(1.0f);
        // glm::mat4 view = glm::lookAt(glm::vec3(0.0f, 0.0f, 3.0f),
        //                              glm::vec3(0.0f, 0.0f, 0.0f),
        //                              glm::vec3(0.0f, 1.0f, 0.0f));
        // glm::mat4 projection = glm::perspective(glm::radians(45.0f),
        //                                         (float)width_ / (float)height_, 0.1f, 100.0f);

        // shader_.setMat4("model", model);
        // shader_.setMat4("view", view);
        // shader_.setMat4("projection", projection);

        // draw simple triangle
        renderer_.drawTriangle(shader_);

        // draw loaded model (check pointer)
        if (model_)
            renderer_.drawModel(*model_);

        glfwSwapBuffers(window_);
        glfwPollEvents();
    }

    return 0;
}
```

utils\camera.cpp:
```cpp
#define GLM_ENABLE_EXPERIMENTAL
#include "camera.h"

#include <iostream>

/**
 * @brief Construct a new Camera:: Camera object
 *
 * @param width
 * @param height
 * @param position
 *
 * Additional Notes:
 * First Person POV, Perspective View
 * - Camera moves with the player
 * - As if the player is seeing through the camera
 *
 * Third Person POV, Orthographic View
 * - Camera follows the player from a set distance (fixed offset)
 * - Player is always visible on screen
 */

Camera::Camera(int width, int height, glm::vec3 position)
{
    this->width = width;
    this->height = height;
    this->Position = position;

    // Initialize camera values
    this->speed = 0.1f;
    this->sensitivity = 0.1f;
    this->yaw = -90.0f;
    this->pitch = 0.0f;
    this->firstClick = true;
    this->cursorCaptured = false;

    // Calculate initial orientation
    glm::vec3 direction;
    direction.x = cos(glm::radians(yaw)) * cos(glm::radians(pitch));
    direction.y = sin(glm::radians(pitch));
    direction.z = sin(glm::radians(yaw)) * cos(glm::radians(pitch));
    this->Orientation = glm::normalize(direction);

    std::cout << "Camera initialized at position: "
              << position.x << ", " << position.y << ", " << position.z << std::endl;
}

void Camera::Matrix(float FOVdeg, float nearPlane, float farPlane, Shader &shader, const char *uniform)
{
    // perspective projection matrix
    glm::mat4 projection = glm::perspective(glm::radians(FOVdeg), (float)width / (float)height, nearPlane, farPlane);
    shader.setMat4(uniform, projection);
}

// can add orthographic projection later

void Camera::Inputs(GLFWwindow *window)
{
    // Debug output for key states
    if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS)
    {
        std::cout << "W pressed - Position before: " << Position.x << ", " << Position.y << ", " << Position.z << std::endl;
        Position += speed * Orientation;
        std::cout << "Position after: " << Position.x << ", " << Position.y << ", " << Position.z << std::endl;
    }

    // Check cursor state
    if (glfwGetKey(window, GLFW_KEY_TAB) == GLFW_PRESS)
    {
        cursorCaptured = !cursorCaptured;
        std::cout << "Cursor captured: " << (cursorCaptured ? "true" : "false") << std::endl;
        glfwSetInputMode(window, GLFW_CURSOR,
                         cursorCaptured ? GLFW_CURSOR_DISABLED : GLFW_CURSOR_NORMAL);
        firstClick = true;
    }

    if (cursorCaptured)
    {
        // Get mouse position
        double mouseX, mouseY;
        glfwGetCursorPos(window, &mouseX, &mouseY);

        if (firstClick)
        {
            lastX = mouseX;
            lastY = mouseY;
            firstClick = false;
        }

        float xOffset = mouseX - lastX;
        float yOffset = lastY - mouseY;
        lastX = mouseX;
        lastY = mouseY;

        // Adjust sensitivity
        xOffset *= sensitivity;
        yOffset *= sensitivity;

        // Middle mouse button for orbit
        if (glfwGetMouseButton(window, GLFW_MOUSE_BUTTON_MIDDLE) == GLFW_PRESS)
        {
            // Orbit around target point
            yaw += xOffset;
            pitch += yOffset;

            // Clamp pitch
            pitch = glm::clamp(pitch, -89.0f, 89.0f);

            // Calculate new position
            float x = cos(glm::radians(yaw)) * cos(glm::radians(pitch));
            float y = sin(glm::radians(pitch));
            float z = sin(glm::radians(yaw)) * cos(glm::radians(pitch));

            Position = target + orbitDistance * glm::normalize(glm::vec3(x, y, z));
            Orientation = glm::normalize(target - Position);
        }
        else
        {
            // Regular first-person camera rotation
            yaw += xOffset;
            pitch += yOffset;
            pitch = glm::clamp(pitch, -89.0f, 89.0f);

            glm::vec3 direction;
            direction.x = cos(glm::radians(yaw)) * cos(glm::radians(pitch));
            direction.y = sin(glm::radians(pitch));
            direction.z = sin(glm::radians(yaw)) * cos(glm::radians(pitch));
            Orientation = glm::normalize(direction);
        }

        // Handle keyboard input
        if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS)
            Position += speed * Orientation;
        if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS)
            Position -= speed * Orientation;
        if (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS)
            Position -= glm::normalize(glm::cross(Orientation, Up)) * speed;
        if (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS)
            Position += glm::normalize(glm::cross(Orientation, Up)) * speed;
        if (glfwGetKey(window, GLFW_KEY_SPACE) == GLFW_PRESS)
            Position += Up * speed;
        if (glfwGetKey(window, GLFW_KEY_LEFT_CONTROL) == GLFW_PRESS)
            Position -= Up * speed;
    }
}

```

main.cpp:
```cpp
#define GLM_ENABLE_EXPERIMENTAL

#include <GL/glew.h>
#include <GLFW/glfw3.h>
#include <fstream>
#include <sstream>
#include <string>
#include <iostream>
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/type_ptr.hpp>

#include "model.h"
#include "camera.h"
#include "app.h"

// utils
static std::string readFile(const char *path)
{
    std::ifstream in(path, std::ios::in | std::ios::binary);
    if (!in)
    {
        std::cerr << "Failed to open file: " << path << "\n";
        return "";
    }
    std::ostringstream contents;
    contents << in.rdbuf();
    return contents.str();
}

static GLuint compileShader(GLenum type, const char *source)
{
    GLuint shader = glCreateShader(type);
    glShaderSource(shader, 1, &source, nullptr);
    glCompileShader(shader);

    GLint compiled = 0;
    glGetShaderiv(shader, GL_COMPILE_STATUS, &compiled);
    if (!compiled)
    {
        GLint len = 0;
        glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &len);
        std::string log(len, ' ');
        glGetShaderInfoLog(shader, len, &len, &log[0]);
        std::cerr << "Shader compile error: " << log << "\n";
        glDeleteShader(shader);
        return 0;
    }
    return shader;
}

static GLuint createProgramFromFiles(const char *vertPath, const char *fragPath)
{
    std::string vertSrc = readFile(vertPath);
    std::string fragSrc = readFile(fragPath);
    if (vertSrc.empty() || fragSrc.empty())
    {
        std::cerr << "One or both shader sources are empty\n";
        return 0;
    }

    GLuint vert = compileShader(GL_VERTEX_SHADER, vertSrc.c_str());
    if (!vert)
        return 0;
    GLuint frag = compileShader(GL_FRAGMENT_SHADER, fragSrc.c_str());
    if (!frag)
    {
        glDeleteShader(vert);
        return 0;
    }

    GLuint program = glCreateProgram();
    glAttachShader(program, vert);
    glAttachShader(program, frag);
    glLinkProgram(program);

    GLint linked = 0;
    glGetProgramiv(program, GL_LINK_STATUS, &linked);
    if (!linked)
    {
        GLint len = 0;
        glGetProgramiv(program, GL_INFO_LOG_LENGTH, &len);
        std::string log(len, ' ');
        glGetProgramInfoLog(program, len, &len, &log[0]);
        std::cerr << "Program link error: " << log << "\n";
        glDeleteProgram(program);
        program = 0;
    }

    // shaders can be detached and deleted after linking
    glDetachShader(program, vert);
    glDetachShader(program, frag);
    glDeleteShader(vert);
    glDeleteShader(frag);

    return program;
}

// glfw window
int main()
{
    const int WIDTH = 1280;
    const int HEIGHT = 960;
    App app(WIDTH, HEIGHT, "Hello World");
    return app.run();
}
```

main.exe:
```
Error reading file: 'utf-8' codec can't decode byte 0x90 in position 2: invalid start byte

<.-File-Contents>

